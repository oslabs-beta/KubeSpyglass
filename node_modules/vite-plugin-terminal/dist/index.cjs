'use strict';

const readline = require('readline');
const kolorist = require('kolorist');
const ufo = require('ufo');
const rollupPluginStrip = require('@rollup/plugin-strip');

function table(obj, indent = 0, doneFirstLineIndent = 0) {
  const table2 = createTable(obj);
  const maxWidth = process.stdout.columns - indent;
  return renderTable(table2, maxWidth, indent, doneFirstLineIndent);
}
function createTable(obj) {
  const keys = Object.keys(obj);
  const shouldRenderValuesCol = keys.some((key) => !isObj(obj[key])) || keys.length === 0;
  const shouldRenderKeyCols = keys.some((key) => isObj(obj[key]));
  const rows = [];
  const allValueKeys = [];
  const headerRow = ["(index)"];
  if (shouldRenderKeyCols) {
    allValueKeys.push(...new Set(keys.flatMap((key) => isObj(obj[key]) ? Object.keys(obj[key]) : [])));
    headerRow.push(...allValueKeys);
  }
  if (shouldRenderValuesCol)
    headerRow.push("Values");
  rows.push(headerRow);
  keys.forEach((key) => {
    const value = obj[key];
    const row = [key];
    if (shouldRenderKeyCols) {
      row.push(...allValueKeys.map((key2) => isObj(value) ? key2 in value ? value[key2] : "" : ""));
      if (shouldRenderValuesCol)
        row.push(isObj(value) ? "" : value);
    } else {
      row.push(value);
    }
    rows.push(row);
  });
  return rows;
}
function renderTable(rows, width, indent = 0, doneFirstLineIndent = 0) {
  const table2 = [];
  const minCellWidth = 5;
  const maxCols = Math.floor((width - 1) / (minCellWidth + 1));
  const rowsToRender = rows.map((row) => row.slice(0, maxCols));
  const nRows = rowsToRender.length;
  const nCols = rowsToRender[0].length;
  const cellWidth = Math.floor((width - (nCols + 1)) / nCols);
  const isTruncated = nCols !== rows[0].length;
  function getCellWidth(index) {
    return index === nCols - 1 ? cellWidth + (width - (cellWidth * nCols + nCols + 1)) : cellWidth;
  }
  function renderRow(row, chars) {
    const start = chars[0];
    const mid = chars[2];
    const end = chars[4];
    return `${kolorist.gray(start)}${row.join(kolorist.gray(mid))}${kolorist.gray(isTruncated ? "\u2026" : end)}`;
  }
  function renderSeparator(chars) {
    const line = chars[1];
    const rows2 = Array.from({ length: nCols }).map((_, index) => kolorist.gray(line.repeat(getCellWidth(index))));
    return renderRow(rows2, chars);
  }
  function renderCell(cell, width2, color) {
    let content;
    content = isObj(cell) ? JSON.stringify(cell) : `${cell}`;
    content = content.length > width2 - 2 ? `${content.slice(0, width2 - 3)}\u2026` : content;
    content = content.padEnd(width2 - 2, " ");
    return color(` ${content} `);
  }
  rowsToRender.forEach((row, index) => {
    if (index === 0)
      table2.push(renderSeparator("\u250F\u2501\u2533\u2501\u2513"));
    const color = index === 0 ? kolorist.lightGray : kolorist.lightMagenta;
    const cells = row.map((cell, index2) => renderCell(cell, getCellWidth(index2), color));
    table2.push(renderRow(cells, index === 0 ? "\u2503 \u2503 \u2503" : "\u2502 \u2502 \u2502"));
    const chars = index === 0 && rowsToRender.length === 1 ? "\u2517\u2501\u253B\u2501\u251B" : index === 0 ? "\u2521\u2501\u2547\u2501\u2529" : index < nRows - 1 ? "\u251C\u2500\u253C\u2500\u2524" : "\u2514\u2500\u2534\u2500\u2518";
    table2.push(renderSeparator(chars));
  });
  return `${" ".repeat(indent - doneFirstLineIndent)}${table2.join(`
${" ".repeat(indent)}`)}`;
}
function isObj(obj) {
  return typeof obj === "object";
}

const DISPATCH_DELAY_TIME_MS = 50;
const queue = [];
const dispatchLog = (log) => {
  addToOrderedQueue(log);
  setTimeout(() => {
    while (queue.length && queue[0].time <= log.time)
      queue.shift().run();
  }, DISPATCH_DELAY_TIME_MS);
};
function addToOrderedQueue(log) {
  const i = queue.findIndex((l) => {
    return l.time > log.time || l.time === log.time && l.count > log.count;
  });
  if (i === -1)
    queue.push(log);
  else
    queue.splice(i, 0, log);
}

const virtualId = "virtual:terminal";
const virtualResolvedId = `\0${virtualId}`;
const virtualId_console = "virtual:terminal/console";
const virtualResolvedId_console = `\0${virtualId_console}`;
const methods = ["assert", "debug", "error", "info", "log", "table", "warn", "clear"];
const colors = {
  log: kolorist.lightMagenta,
  info: kolorist.lightGray,
  debug: kolorist.lightBlue,
  warn: kolorist.lightYellow,
  error: kolorist.lightRed,
  assert: kolorist.lightRed
};
const groupText = (text, groupLevel) => {
  if (groupLevel !== 0)
    return `${"  ".repeat(groupLevel)}${text.split("\n").join(`
${"  ".repeat(groupLevel)}`)}`;
  else
    return text;
};
function pluginTerminal(options = {}) {
  const {
    include = /.+\.(js|ts|mjs|cjs|mts|cts)/,
    exclude
  } = options;
  let config;
  let virtualModuleCode;
  const terminal = {
    name: "vite-plugin-terminal",
    configResolved(_config) {
      config = _config;
    },
    resolveId(id = "") {
      if (id === virtualId)
        return virtualResolvedId;
      if (id === virtualId_console)
        return virtualResolvedId_console;
    },
    load(id) {
      if (id === virtualResolvedId) {
        virtualModuleCode || (virtualModuleCode = generateVirtualModuleCode(config.server?.origin ?? "", options.output));
        return virtualModuleCode;
      }
      if (id === virtualResolvedId_console)
        return 'import terminal from "virtual:terminal"; globalThis.console = terminal';
    },
    transformIndexHtml: {
      enforce: "pre",
      transform() {
        if (options.console === "terminal") {
          return [{
            tag: "script",
            attrs: { type: "module", src: "/@id/__x00__virtual:terminal/console" }
          }];
        }
      }
    },
    configureServer(server) {
      server.middlewares.use("/__terminal", (req, res) => {
        const { pathname, search } = ufo.parseURL(req.url);
        const searchParams = new URLSearchParams(search.slice(1));
        const message = decodeURI(searchParams.get("m") ?? "").split("\n").join("\n  ");
        const time = parseInt(searchParams.get("t") ?? "0");
        const count = parseInt(searchParams.get("c") ?? "0");
        const groupLevel = parseInt(searchParams.get("g") ?? "0");
        if (pathname[0] === "/") {
          const method = pathname.slice(1);
          if (methods.includes(method)) {
            let run;
            switch (method) {
              case "clear": {
                run = () => {
                  if (process.stdout.isTTY && !process.env.CI) {
                    const repeatCount = process.stdout.rows - 2;
                    const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
                    console.log(blank);
                    readline.cursorTo(process.stdout, 0, 0);
                    readline.clearScreenDown(process.stdout);
                  }
                };
                break;
              }
              case "table": {
                const obj = JSON.parse(message);
                const indent = 2 * (groupLevel + 1);
                run = () => config.logger.info(`\xBB ${table(obj, indent, 2)}`);
                break;
              }
              default: {
                const color = colors[method];
                const groupedMessage = groupText(message, groupLevel);
                run = () => config.logger.info(color(`\xBB ${groupedMessage}`));
                break;
              }
            }
            dispatchLog({ run, time, count });
          }
        }
        res.end();
      });
    }
  };
  const strip = {
    ...rollupPluginStrip({
      include,
      exclude,
      functions: methods.map((name) => `terminal.${name}`)
    }),
    apply: "build"
  };
  return [terminal, options.strip !== false && strip];
}
function generateVirtualModuleCode(url, output) {
  const outputToTerminal2 = output ? output === "terminal" || output.includes("terminal") : true;
  const outputToConsole2 = output ? output === "console" || output.includes("console") : false;
  return `const outputToTerminal = ${outputToTerminal2}
const terminalUrl = "${url}"
const outputToConsole = ${outputToConsole2}
export const terminal = ${createTerminal.toString()}()
export default terminal
`;
}
function createTerminal() {
  const console2 = globalThis.console;
  let count = 0;
  let groupLevel = 0;
  const counters = /* @__PURE__ */ new Map();
  const timers = /* @__PURE__ */ new Map();
  function getTimer(id) {
    return timers.has(id) ? `${id}: ${performance.now() - timers.get(id)} ms` : `Timer ${id} doesn't exist`;
  }
  function stringify(obj) {
    return JSON.stringify(obj);
  }
  function prettyPrint(obj) {
    return JSON.stringify(obj, null, 2);
  }
  function stringifyObjs(objs) {
    const obj = objs.length > 1 ? objs.map(stringify).join(" ") : objs[0];
    return typeof obj === "object" ? `${prettyPrint(obj)}` : obj.toString();
  }
  function send(type, message) {
    const encodedMessage = message ? `&m=${encodeURI(message)}` : "";
    fetch(`${terminalUrl}/__terminal/${type}?t=${Date.now()}&c=${count++}&g=${groupLevel}${encodedMessage}`, { mode: "no-cors" });
  }
  const terminal = {
    log(...objs) {
      send("log", stringifyObjs(objs));
    },
    info(...objs) {
      send("info", stringifyObjs(objs));
    },
    debug(...objs) {
      send("debug", stringifyObjs(objs));
    },
    warn(...objs) {
      send("warn", stringifyObjs(objs));
    },
    error(...objs) {
      send("error", stringifyObjs(objs));
    },
    assert(assertion, ...objs) {
      if (!assertion)
        send("assert", `Assertion failed: ${stringifyObjs(objs)}`);
    },
    table(obj) {
      send("table", prettyPrint(obj));
    },
    group() {
      groupLevel++;
    },
    groupCollapsed() {
      groupLevel++;
    },
    groupEnd() {
      groupLevel && --groupLevel;
    },
    time(id) {
      timers.set(id, performance.now());
    },
    timeLog(id, ...objs) {
      send("log", `${getTimer(id)} ${stringifyObjs(objs)}`);
    },
    timeEnd(id) {
      send("log", getTimer(id));
      timers.delete(id);
    },
    count(label) {
      const l = label || "default";
      const n = (counters.get(l) || 0) + 1;
      counters.set(l, n);
      send("log", `${l}: ${n}`);
    },
    countReset(label) {
      const l = label || "default";
      counters.set(l, 0);
      send("log", `${l}: 0`);
    },
    clear() {
      send("clear");
    },
    dir(obj) {
      send("log", prettyPrint(obj));
    },
    dirxml(obj) {
      send("log", prettyPrint(obj));
    },
    trace(...args) {
      console2.trace(...args);
    },
    profile(...args) {
      console2.profile(...args);
    },
    profileEnd(...args) {
      console2.profileEnd(...args);
    }
  };
  function defineOutput(terminal2) {
    if (!outputToConsole)
      return terminal2;
    if (!outputToTerminal)
      return console2;
    const unsupportedMethods = ["trace", "profile", "profileEnd"];
    const multicast = {};
    Object.keys(terminal2).forEach((method) => {
      multicast[method] = unsupportedMethods.includes(method) ? console2[method] : (...args) => {
        console2[method](...args);
        terminal2[method](...args);
      };
    });
    return multicast;
  }
  return defineOutput(terminal);
}

module.exports = pluginTerminal;
